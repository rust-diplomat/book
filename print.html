<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Diplomat Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="user.html"><strong aria-hidden="true">2.</strong> User Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics.html"><strong aria-hidden="true">2.1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="types.html"><strong aria-hidden="true">2.2.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="opaque.html"><strong aria-hidden="true">2.2.1.</strong> Opaque types</a></li><li class="chapter-item expanded "><a href="structs.html"><strong aria-hidden="true">2.2.2.</strong> Structs and enums</a></li><li class="chapter-item expanded "><a href="option.html"><strong aria-hidden="true">2.2.3.</strong> Options</a></li><li class="chapter-item expanded "><a href="result.html"><strong aria-hidden="true">2.2.4.</strong> Results</a></li><li class="chapter-item expanded "><a href="writeable.html"><strong aria-hidden="true">2.2.5.</strong> Writeable</a></li></ol></li><li class="chapter-item expanded "><a href="docs.html"><strong aria-hidden="true">2.3.</strong> Documentation</a></li><li class="chapter-item expanded "><a href="lifetimes.html"><strong aria-hidden="true">2.4.</strong> Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="developer.html"><strong aria-hidden="true">3.</strong> Backend developer guide</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Diplomat Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://github.com/rust-diplomat/diplomat">Diplomat</a> is a framework and tool for generating bindings to Rust libraries from an extensible set of languages.</p>
<p>Diplomat is for <em>unidirectional</em> bindings: it's for when foreign code wishes to call into a Rust library, but not vice versa. If you're looking for bidirectional bindings, tools like <a href="https://github.com/dtolnay/cxx">cxx</a> are a good bet.</p>
<p>Diplomat is a proc macro paired with a tool. The proc macro is capable of generating an <code>extern "C"</code> binding layer around tagged Rust code, while the tool is able to generate corresponding C, C++, JS, or <code>&lt;insert language here&gt;</code> that philosophically matches the API on the Rust side. This means that methods in Rust map to "methods" in the target language, <code>Result</code> in Rust map to tagged unions in C++ and exceptions in Javascript, etc. These all work through the generated C API, however they preserve higher level API features which C cannot express.</p>
<h2 id="a-note-on-the-design"><a class="header" href="#a-note-on-the-design">A note on the design</a></h2>
<p>You can read the full design doc <a href="https://github.com/rust-diplomat/diplomat/blob/main/docs/design_doc.md">here</a>.</p>
<p>Diplomat does not do cross-crate global analysis, it restricts its view to specially tagged modules, and only generates bindings based on information found in those modules. This means that changing some struct in some dependency will not magically affect your generated C++/JS/etc APIs; all such change can only come from deliberate change to these tagged modules. This also means that Diplomat can cleanly define a subset of Rust used for declaring the exported API without impacting the flavor of Rust used in dependencies. One can imagine <code>#[diplomat::bridge]</code> blocks to almost be a DSL for bridging between your Rust APIs and a more general API shape that can be translated cleanly across languages.</p>
<p>Diplomat is designed such that it should not be a large amount of effort to write new language targets for Diplomat.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>To install the <code>diplomat</code> CLI tool, run</p>
<pre><code class="language-shell">$ cargo install diplomat-tool
</code></pre>
<p>You can then add <code>diplomat</code> as a dependency to your project like so:</p>
<pre><code class="language-toml">diplomat = "0.5.0"
diplomat-runtime = "0.5.0"
</code></pre>
<p>It is recommended to create a separate crate for the FFI interface. Diplomat will only read the contents of specially tagged modules so it is possible to mix Diplomat code with normal Rust code, but it is prefereable to minimize this since proc macros can make debugging hard.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-guide"><a class="header" href="#user-guide">User Guide</a></h1>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>To install the <code>diplomat</code> CLI tool, run</p>
<pre><code class="language-shell">$ cargo install diplomat-tool
</code></pre>
<p>You can then add <code>diplomat</code> as a dependency to your project like so:</p>
<pre><code class="language-toml">diplomat = "0.5.0"
diplomat-runtime = "0.5.0"
</code></pre>
<p>It is recommended to create a separate crate for the FFI interface. Diplomat will only read the contents of specially tagged modules so it is possible to mix Diplomat code with normal Rust code, but it is prefereable to minimize this since proc macros can make debugging hard.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>When using Diplomat, you'll need to define Rust modules that contain the Rust APIs you want to expose. You can do this by using the <code>diplomat::bridge</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    pub struct MyFFIStruct {
        pub a: i32,
        pub b: bool,
    }
    
    impl MyFFIStruct {
        pub fn create() -&gt; MyFFIStruct {
            MyFFIStruct {
                a: 42,
                b: true
            }
        }

        pub fn do_a_thing(self) {
            println!("doing thing {:?}", self.b);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is a simple struct with public fields; which is easier to reason about in an introductory example. <em>Most</em> APIs exposed via Diplomat will be via "opaque types", to be covered in the <a href="./opaque.html">chapter on opaque types</a>.</p>
<p>Every type declared within a <code>diplomat::bridge</code> module along with all methods in its associated impl will be exposed over FFI. For example, the above code will generate the following extern API:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
extern "C" fn MyFFIStruct_create() -&gt; MyFFIStruct {
    MyFFIStruct::create()
}

#[no_mangle]
extern "C" fn MyFFIStruct_do_a_thing(this: &amp;MyFFIStruct) {
    this.do_a_thing()
}
<span class="boring">}</span></code></pre></pre>
<p>We can then generate the bindings for this API using the <code>diplomat-tool</code> CLI.</p>
<h2 id="c"><a class="header" href="#c">C++</a></h2>
<p>For example, if we want to generate C++ bindings, we can create a folder `cpp/`` and generate bindings in it by running:</p>
<pre><code class="language-shell">$ diplomat-tool cpp cpp/
</code></pre>
<p>This will generate the following struct in <code>MyFFIStruct.hpp</code>, along with some boilerplate:</p>
<pre><code class="language-cpp">struct MyFFIStruct {
 public:
  int32_t a;
  bool b;
  static MyFFIStruct create();
  void do_a_thing();
};
</code></pre>
<p>If we want to generate Sphinx documentation to cpp-docs, we can run with that as an additional parameter:</p>
<pre><code class="language-shell">$ diplomat-tool cpp cpp/ --docs cpp-docs/
</code></pre>
<h2 id="wasm"><a class="header" href="#wasm">WASM</a></h2>
<p>For WASM JS/TypeScript bindings, you can use the following options, with similarly named directories:</p>
<pre><code class="language-shell">$ diplomat-tool js js/ --docs js/docs/
</code></pre>
<p>This will generate JS that has a <code>MyFFIStruct</code> class, with a static <code>create()</code> method, a <code>do_a_thing()</code> method, and getters for the fields. This JS will require there to be a <code>wasm.mjs</code> file that loads in the built wasm file (See <a href="https://github.com/rust-diplomat/diplomat/issues/80">issue #80</a> for improving this), which you can base off of <a href="https://github.com/rust-diplomat/diplomat/blob/38cffa9bc2ef21d0aba89ed7d76236de4153248a/example/js/wasm.mjs">this file</a>.</p>
<h2 id="c-1"><a class="header" href="#c-1">C</a></h2>
<p>While low-level C headers are generated in the process of running <code>diplomat-tool cpp</code>, you can also generate just the C headers with</p>
<pre><code class="language-shell">$ diplomat-tool c c/
</code></pre>
<p>Note that Diplomat's C mode generates direct bindings to the lower level <code>extern "C"</code> API, and is not idiomatic C code. It is recommended that one build a higher level API around the C API (perhaps by writing a plugin) if C bindings are desired.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>Diplomat only supports a small set of types that can be passed over FFI. These are:</p>
<ul>
<li>Builtins:
<ul>
<li>All integers, as well as <code>bool</code> and <code>char</code></li>
<li><code>&amp;[T]</code> where <code>T</code> is an integer, <code>bool</code>, or <code>char</code></li>
<li><code>&amp;str</code> (string slices)</li>
<li><a href="./writeable.html"><code>DiplomatWriteable</code></a> for returning strings</li>
<li><a href="./result.html"><code>Result&lt;T, E&gt;</code></a> in return values</li>
<li><a href="./option.html"><code>Option&lt;T&gt;</code></a> of opaque types</li>
<li><code>()</code> as a <code>Result</code> <code>Ok</code>/<code>Error</code> type, or as a return value</li>
</ul>
</li>
<li>Custom types
<ul>
<li>Custom <a href="./opaque.html">opaque types</a> (passed as references or via <code>Box&lt;T&gt;</code>)</li>
<li>Custom <a href="./structs.html">structs and C-like enums</a></li>
</ul>
</li>
</ul>
<p>More types can be supported in the future (We have issues for <a href="https://github.com/rust-diplomat/diplomat/issues/251">iterators</a> and <a href="https://github.com/rust-diplomat/diplomat/issues/146">callbacks</a>)</p>
<p>The <em>main</em> distinction to keep track of is between "opaque types" and "structs": opaque types are for when you want to wrap a Rust object that has its own semantics, whereas "structs" are for when you want to transparently pass around multiple values at once (usually when you want to make an options struct as an argument, or return multiple values at once).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opaque-types"><a class="header" href="#opaque-types">Opaque Types</a></h1>
<p>In the vast majority of cases, we'd like to expose Rust types over FFI "opaquely", that is, the FFI code does not know anything about the contents of these types, rather it wants to do things with the type.</p>
<p>By default, Diplomat will not let you expose fields of types other than the <a href="./types.html">allowed types</a> over FFI. The following code will trigger a resolution error when running <code>diplomat-tool</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    pub struct MyFFIType {
        pub a: i32,
        pub b: Vec&lt;String&gt;, // or "SomeTypeDefinedElsewhere"
    }
    
    impl MyFFIType {
        pub fn create() -&gt; MyFFIType {
            todo!()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Of course, if Diplomat is to be able to usefully expose Rust APIs without requiring everything be defined within Diplomat's bridge blocks, there has to be some way to include them in this the API.</p>
<p>For this in Diplomat we declare <em>opaque types</em>, which can only exist behind pointers. Such types can contain whatever they want, but they can never be passed over the stack through FFI, and the other side cannot peek into them in ways other than calling explicitly defined methods.</p>
<p>For example, say we have the following type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyCollection {
    name: String,
    items: Vec&lt;String&gt;,
}

impl MyCollection {
    fn new(name: String) -&gt; Self {
        Self {
            name, items: vec![]
        }
    }

    fn push(&amp;mut self, s: String) {
        self.items.push(s)
    }

    fn dump(&amp;self) {
        println!("Collection {} with items {:?}", self.name, self.items);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To expose it over FFI, we'd do something like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    // import this from wherever, does not need
    // to be the same crate
    use super::MyCollection as RustCollection;

    #[diplomat::opaque]
    pub struct MyCollection(RustCollection);

    impl MyCollection {
        pub fn create(s: &amp;str) -&gt; Box&lt;MyCollection&gt; {
            Box::new(MyCollection(RustCollection::new(s.into())))
        }

        pub fn push(&amp;mut self, s: &amp;str) {
            self.0.push(s.into())
        }

        pub fn dump(&amp;self) {
            self.0.dump()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This will generate code exposing <code>create()</code>, <code>push()</code>, and <code>dump()</code> over FFI, as well as glue to ensure the destructor is called. However this will not expose any way to get at the <code>RustCollection</code>.</p>
<p>For example, the generated C++ looks something like</p>
<pre><code class="language-cpp">class MyCollection {
 public:
  static MyCollection create(const std::string_view s);
  void push(const std::string_view s);
  void dump();
  // snip
 private:
  // just a pointer with a custom destructor
  std::unique_ptr&lt;capi::MyCollection, MyCollectionDeleter&gt; inner;
};
</code></pre>
<p>When exposing your library over FFI, most of the main types will probably end up being "opaque".</p>
<h1 id="boxes-are-return-only"><a class="header" href="#boxes-are-return-only">Boxes are return-only</a></h1>
<p><code>Box&lt;T&gt;</code> can only be returned, not accepted as a parameter. This is because in garbage collected languages it is not possible to know if we are the unique owner when converting back to Rust. There are some techniques we could use to add such functionality, see <a href="https://github.com/rust-diplomat/diplomat/issues/317">#317</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-and-enums"><a class="header" href="#structs-and-enums">Structs and enums</a></h1>
<p>Diplomat allows for exposing basic structs and enums over FFI. Typically these should be used as inputs and outputs to other methods, rather than having methods of their own, however it is possible to give them methods which capture <code>self</code> by-value.</p>
<p>Structs are most commonly found when making an options type for a method, or when doing multiple return values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    use my_thingy::MyThingy;

    // just exists so we can get methods
    #[diplomat::opaque]
    pub struct Thingy(MyThingy);

    pub struct ThingySettings {
        pub a: bool,
        pub b: u8,
        pub speed: SpeedSetting,
    }

    #[diplomat::enum_convert(my_thingy::SpeedSetting)]
    pub enum SpeedSetting {
        Fast, Medium, Slow
    }

    #[diplomat::enum_convert(my_thingy::ThingyStatus)]
    pub enum ThingyStatus {
        Good,
        Bad
    }

    impl Thingy {
        pub fn create(settings: ThingySettings) -&gt; Box&lt;Thingy&gt; {
            // Convert our FFI type to whatever internal settings type was needed
            let settings = my_thingy::ThingySettings {
                a: settings.a,
                b: settings.b,
                speed: settings.speed.into()
            };
            Box::new(Thingy::new(settings))
        }

        pub fn get_status(&amp;self) -&gt; ThingyStatus {
            self.0.get_status().into()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Enums exposed via Diplomat must be simple C-like enums. Structs may only contain fields which are <a href="./types.html">allowed</a>.</p>
<p>In C++ the structs are translated to simple structs and the enums become simple enum classes. In JS the structs become objects with fields, and the enums are exposed as strings that get converted at the boundary.</p>
<h1 id="diplomatenum_convert"><a class="header" href="#diplomatenum_convert"><code>diplomat::enum_convert</code></a></h1>
<p>Diplomat can autogenerate <code>Into</code> impls to an enum from your library using <code>#[diplomat::enum_convert]</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    // ...

    #[diplomat::enum_convert(my_thingy::SpeedSetting)]
    enum SpeedSetting {
        Fast, Medium, Slow
    }

    // ...

}
<span class="boring">}</span></code></pre></pre>
<p>In case the enum is <code>#[non_exhaustive]</code>, you may need to supply a <code>needs_wildcard</code> argument, like so: <code>#[diplomat::enum_convert(my_library::SpeedSetting)]</code>.</p>
<h1 id="structs-containing-boxes"><a class="header" href="#structs-containing-boxes">Structs containing boxes</a></h1>
<p>By default, structs cannot contain output-only types like <code>Box&lt;T&gt;</code>. This can be opted in to by using <code>#[diplomat::out]</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod ffi {
    use my_thingy::MyThingy;

    #[diplomat::opaque]
    pub struct Thingy(=MyThingy);

    #[diplomat::out]
    pub struct ThingyAndExtraStuff {
        pub thingy: Box&lt;Thingy&gt;,
        pub stuff: u32
    }

    impl Thingy {
        pub fn create() -&gt; ThingyAndExtraStuff {
            let thingy = Box::new(Thingy(MyThingy::new()));
            let stuff = 42;
            ThingyAndExtraStuff {
                thingy, stuff
            }
        }
    }

}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="option-types"><a class="header" href="#option-types">Option types</a></h1>
<p>Option types in Diplomat are relatively straightforward, you simply use <code>Option&lt;T&gt;</code> and it turns into the idiomatic equivalent over FFI.</p>
<p><code>Option&lt;T&gt;</code> currently only works when wrapping reference types (<code>Box&lt;OpaqueType&gt;</code> and <code>&amp;OpaqueType</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    // just exists so we can get methods
    #[diplomat::opaque]
    pub struct Thingy;

    impl Thingy {
        fn maybe_create() -&gt; Option&lt;Box&lt;Thingy&gt;&gt; {
            Some(Box::new(Thingy))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In C++ this will return a <code>std::option&lt;Thingy&gt;</code>, and in JS it will return a potentially-null object.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-types"><a class="header" href="#result-types">Result types</a></h1>
<p>Result types are returned by using <a href="https://docs.rs/diplomat-runtime/0.2.0/diplomat_runtime/struct.DiplomatResult.html"><code>Result&lt;T, E&gt;</code></a> (or <code>DiplomatResult&lt;T, E&gt;</code>).</p>
<p>For example, let's say we wish to define a fallible constructor:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    #[diplomat::opaque]
    struct Thingy(u8);

    impl Thingy {
        pub fn try_create(string: &amp;str) -&gt; Result&lt;Box&lt;Thingy&gt;, ()&gt; {
            let parsed: Result&lt;u8, ()&gt; = string.parse().map_err(|_| ());
            parsed.map(Thingy).map(Box::new)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>On the C++ side, this will generate a method on <code>Thingy</code> with the signature</p>
<pre><code class="language-cpp">  static diplomat::result&lt;Thingy, std::monostate&gt; try_create(const std::string_view string);
</code></pre>
<p><code>diplomat::result</code> is a type that can be found in the generated <a href="https://github.com/rust-diplomat/diplomat/blob/main/tool/src/cpp/runtime.hpp"><code>diplomat_runtime.hpp</code></a> file. The most basic APIs are <code>.is_ok()</code> and <code>.is_err()</code>, returning <code>bool</code>s, and <code>.ok()</code> and <code>.err()</code> returning <code>std::option</code>s. There are further APIs for constructing and manipulating these that can be found in the header file.</p>
<p>On the JS side it will continue to return the <code>Thingy</code> class but it will <code>throw</code> the error (as an empty object in this case) in case of an error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writeables"><a class="header" href="#writeables">Writeables</a></h1>
<p>Most languages have their own type to handle strings. To avoid unnecessary allocations, Diplomat supports <a href="https://docs.rs/diplomat-runtime/0.2.0/diplomat_runtime/struct.DiplomatWriteable.html"><code>DiplomatWriteable</code></a>, a type with a <code>Write</code> implementation which can be used to write to appropriate string types on the other side.</p>
<p>For example, if we want to have methods that philosophically return a <code>String</code> or a <code>Result&lt;String&gt;</code>, we can do the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    use diplomat_runtime::DiplomatWriteable;
    use std::fmt::Write;

    #[diplomat::opaque]
    #[derive(Debug)]
    pub struct Thingy(u8);

    impl Thingy {
        pub fn debug_output(&amp;self, writeable: &amp;mut DiplomatWriteable) {
            write!(writeable, "{:?}", self);
        }

        pub fn maybe_get_string(&amp;self, writeable: &amp;mut DiplomatWriteable) -&gt; Result&lt;(), ()&gt; {
            write!(writeable, "integer is {}", self.0).map_err(|_| ())
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>On the JS side these will get converted to APIs that return strings (<code>maybe_get_string</code> will potentially throw in the case of an error, as is usual with <code>DiplomatResult</code>)</p>
<p>In C++ multiple APIs are generated:</p>
<pre><code class="language-cpp">  std::string debug_output();
  diplomat::result&lt;std::string, std::monostate&gt; maybe_get_string();
// and
  template&lt;typename W&gt; void debug_output_to_writeable(W&amp; writeable);
  template&lt;typename W&gt; diplomat::result&lt;std::monostate, std::monostate&gt; maybe_get_string_to_writeable(W&amp; writeable);
</code></pre>
<p>Essentially, versions of the API returning <code>std::string</code> are generated, where the <code>write!()</code> operation will end up writing <em>directly to the <code>std::string</code></em> with no additional intermediate Rust <code>String</code> allocations.</p>
<h2 id="writeabletrait"><a class="header" href="#writeabletrait">WriteableTrait</a></h2>
<p>The template versions work on any type that is hooked into <code>WriteableTrait</code>, allowing . Types can be hooked into <code>WriteableTrait</code> as follows:</p>
<pre><code class="language-cpp">template&lt;&gt; struct WriteableTrait&lt;MyStringType&gt; {
  static inline capi::DiplomatWriteable Construct(MyStringType&amp; t) {
    // ...
  }
}
</code></pre>
<p>This requires constructing a <a href="https://docs.rs/diplomat-runtime/0.2.0/diplomat_runtime/struct.DiplomatWriteable.html"><code>DiplomatWriteable</code></a> from the custom string type, which is documented in more detail <a href="https://github.com/rust-diplomat/diplomat/blob/38cffa9bc2ef21d0aba89ed7d76236de4153248a/runtime/src/writeable.rs#L6-L62">in the source</a>. Essentially, it involves constructing an ad-hoc virtual dispatch object for the type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation"><a class="header" href="#documentation">Documentation</a></h1>
<p>Some Diplomat backends support <code>--docs</code>, which will generate additional documentation from your Markdown doc comments</p>
<pre><code class="language-shell">$ diplomat-tool cpp cpp/ --docs cpp-docs/
</code></pre>
<p>The C++ and JS backends generate Sphinx docs. If using TypeScript, the definition files will automatically come with <code>tsdoc</code>-compatible doc comments.</p>
<p>A limited amount of intra-doc-links are supported: it is possible to link to custom <em>types</em> (but not methods or variants) using <code>[`FooBar`]</code> syntax, like Rust.</p>
<p>Furthermore, you can use <code>#[diplomat::rust_link(path::to::rust::type, Struct)]</code> to autogenerate links for to published docs, which typically show up as a "For more information see &lt;link&gt;" at the bottom of the docs for the given item. Since Diplomat cannot do resolution on other crates, it relies on the <code>rust_link</code> annotation to provide the kind of Rust item or doc page being linked to. An additional <code>compact</code> parameter can be passed in case you wish to provide multiple <code>rust_link</code>s that are to be collapsed into a single "For more information see 1, 2, 3" line.</p>
<p>Put together, this might look something like the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {
    use my_thingy::MyThingy;

    /// A Thingy
    #[diplomat::rust_link(my_thingy::MyThingy, Struct)]
    #[diplomat::opaque]
    pub struct Thingy(MyThingy);

    #[diplomat::enum_convert(my_thingy::SpeedSetting)]
    #[diplomat::rust_link(my_thingy::SpeedSetting, Enum)]
    pub enum SpeedSetting {
        Fast, Medium, Slow
    }

    #[diplomat::enum_convert(my_thingy::ThingyStatus)]
    #[diplomat::rust_link(my_thingy::ThingyStatus, Enum)]
    pub enum ThingyStatus {
        Good,
        Bad
    }

    impl Thingy {
        /// Make a [`MyThingy`]!
        #[diplomat::rust_link(my_thingy::MyThingy::new, FnInStruct)]
        pub fn create(speed: SpeedSetting) -&gt; Box&lt;Thingy&gt; {
            Box::new(Thingy(Thingy::new(speed.into())))
        }

        /// Get the status
        #[diplomat::rust_link(my_thingy::MyThingy::get_status, FnInStruct)]
        pub fn get_status(&amp;self) -&gt; ThingyStatus {
            self.0.get_status().into()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The full list of item kinds recognized by <code>rust_link</code> is:</p>
<ul>
<li><code>Struct</code></li>
<li><code>StructField</code></li>
<li><code>Enum</code></li>
<li><code>EnumVariant</code></li>
<li><code>EnumVariantField</code></li>
<li><code>Trait</code></li>
<li><code>FnInStruct</code></li>
<li><code>FnInEnum</code></li>
<li><code>FnInTrait</code></li>
<li><code>DefaultFnInTrait</code></li>
<li><code>Fn</code></li>
<li><code>Mod</code></li>
<li><code>Constant</code></li>
<li><code>AssociatedConstantInEnum</code></li>
<li><code>AssociatedConstantInTrait</code></li>
<li><code>AssociatedConstantInStruct</code></li>
<li><code>Macro</code></li>
<li><code>AssociatedTypeInEnum</code></li>
<li><code>AssociatedTypeInTrait</code></li>
<li><code>AssociatedTypeInStruct</code></li>
<li><code>Typedef</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>Diplomat <em>is</em> able to safely handle methods that do complex borrowing, as long as the lifetimes are fully specified (i.e., not elided).</p>
<p>In general, Diplomat attempts to follow language norms when it comes to patterns akin to borrowing. In C++, for example, the norm is to document the behavior of a method, which is what Diplomat does. However, in JS, the norm is to not have use-after-frees, which Diplomat attempts to achieve by stashing extra references to borrowed-from objects.</p>
<p>For example, let's take this iterator API:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[diplomat::bridge]
mod ffi {

    #[diplomat::opaque]
    pub struct MyFancyVec(Vec&lt;u32&gt;); // not very fancy

    pub struct MyFancyIterator&lt;'a&gt;(std::slice::Iter&lt;'a, u32&gt;);


    impl MyFancyVec {
        pub fn new(count: usize) -&gt; Box&lt;MyFancyVec&gt; {
            // make a random vector, this is an example
            let vec = (5..(count + 5)).collect();
            Box::new(MyFancyVec(vec));
        }

        pub fn iter&lt;'a&gt;(&amp;'a self) -&gt; Box&lt;MyFancyIterator&lt;'a&gt;&gt; {
            Box::new(MyFancyIterator(self.0.iter()))
        }
    }

    impl&lt;'a&gt; MyFancyIterator&lt;'a&gt; {
        fn next(&amp;mut self) -&gt; u32 {
            // We don't support Option of primitives in Diplomat currently
            // Just default to 0. We could use a struct to represent this instead
            // but it's not relevant to the example
            self.0.next().copied().unwrap_or(0)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It's crucial the return type of <code>MyFancyVec::iter()</code> is not held on to longer than the <code>MyFancyVec</code> it came from.</p>
<p>In C++, this will produce documentation that looks like the following:</p>
<pre><code>Lifetimes: `self` must live at least as long as the output.
</code></pre>
<p>On the other hand, in JS, the JS object wrapping <code>MyFancyIterator</code> will internally stash a reference to the <code>MyFancyVec</code>, which will be noticed by the GC, keeping the vector alive as long as needed.</p>
<p>This also works with non-opaque structs; you can have a function that takes in a struct where one field has a lifetime, and returns a different struct with a similar property, and Diplomat will document or GC-link the appropriate fields.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-set-up-a-minimal-backend"><a class="header" href="#how-to-set-up-a-minimal-backend">How to Set up a Minimal Backend</a></h1>
<p>How to create a backend is quite language dependent, and what is easier in one
may be harder in another. Below we will start setting up a simple backend. We'll
show you how to set up a test in diplomat so you can start generating code quickly.
Then we give you a template for a simple dynamic library that you can then link
to your host language. Finally we provide a suggested checklist for your backend.
It is not automatically generated so when in doubt look at diplomat's <a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/index.html">HIR</a></p>
<ul>
<li><input disabled="" type="checkbox"/>
<strong>project structure</strong>: You will need need to test your generated code so you should
first set up a host language project. It should have all dependencies to be able to interface
with native code (or WASM).</li>
</ul>
<h2 id="setting-up-basic-code-generation-in-a-test"><a class="header" href="#setting-up-basic-code-generation-in-a-test">Setting up Basic Code Generation in a Test</a></h2>
<p>Your backend should iterate over all <a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/enum.TypeDef.html"><code>TypeDefs</code></a>
and generate the required code for these. To do that we start with an
<a href="https://docs.rs/diplomat_core/latest/diplomat_core/ast/struct.File.html"><code>ast::File</code></a>, which can
then be parsed into a <a href="https://docs.rs/diplomat_core/latest/diplomat_core/struct.Env.html"><code>Env</code></a>
using the
<a href="https://docs.rs/diplomat_core/latest/diplomat_core/ast/struct.File.html#method.all_types"><code>all_types</code></a>
method. Then we can create the
<a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/struct.TypeContext.html"><code>TypeContext</code></a>
which is generated using the
<a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/struct.TypeContext.html#method.from_ast"><code>from_ast</code></a>
method. You will also need an
<a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/trait.AttributeValidator.html"><code>AttributeValidator</code></a>,
but should probably start with the simple
<a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/struct.BasicAttributeValidator.html"><code>BasicAttributeValidator</code></a>.</p>
<p>We will now build an example by way of a test. A good starting point is to create a test for
generating a simple opaque struct without any methods. Your backend should go in the tool crate:
create a module <code>tool/src/{backend}/mod.rs</code>  (make sure you add a line <code>pub mod backend;</code> to
<code>tool/src/lib.rs</code>). Add the following to it</p>
<pre><code class="language-rs">use diplomat_core::hir::{OpaqueDef, TypeContext, TypeId};

fn gen_opaque_def(ctx: &amp;TypeContext, type_id: TypeId, opaque_path: &amp;OpaqueDef) -&gt; String {
    "We'll get to it".into()
}

#[cfg(test)]
mod test {
    use diplomat_core::{
        ast::{self},
        hir::{self, TypeDef},
    };
    use quote::quote;

    #[test]
    fn test_opaque_gen() {
        let tokens = quote! {
            #[diplomat::bridge]
            mod ffi {

                #[diplomat::opaque]
                struct OpaqueStruct;

            }
        };
        let item = syn::parse2::&lt;syn::File&gt;(tokens).expect("failed to parse item ");

        let diplomat_file = ast::File::from(&amp;item);
        let env = diplomat_file.all_types();
        let attr_validator = hir::BasicAttributeValidator::new("my_backend_test");

        let context = match hir::TypeContext::from_ast(&amp;env, attr_validator) {
            Ok(context) =&gt; context,
            Err(e) =&gt; {
                for (_cx, err) in e {
                    eprintln!("Lowering error: {}", err);
                }
                panic!("Failed to create context")
            }
        };

        let (type_id, opaque_def) = match context
            .all_types()
            .next()
            .expect("Failed to generate first opaque def")
        {
            (type_id, TypeDef::Opaque(opaque_def)) =&gt; (type_id, opaque_def),
            _ =&gt; panic!("Failed to find opaque type from AST"),
        };

        let generated = super::gen_opaque_def(&amp;context, type_id, opaque_def);

        insta::assert_snapshot!(generated)
    }
}
</code></pre>
<p>You can now run</p>
<pre><code class="language-sh">cargo test -p diplomat-tool -- backend::test --nocapture
</code></pre>
<p>You should also have a generated snapshot <code>diplomat_tool__backend__test__opaque_gen.snap.new</code>
which you can use to pick up your generated code.</p>
<h2 id="how-to-generate-the-library"><a class="header" href="#how-to-generate-the-library">How to Generate the Library</a></h2>
<p>Now to actually test native methods you will need to create some kind of library, be it static, dynamic, or
even WASM. In the following we will be creating a dynamically linked library.</p>
<p>You should set up a separate rust project next to your diplomat fork e.g. <code>mybackendtest</code></p>
<pre><code class="language-sh">cargo new --lib mybackendtest
</code></pre>
<p>with the following Cargo.toml</p>
<pre><code class="language-toml">[package]
name = "mybackendtest"
version = "0.1.0"
edition = "2021"

[lib]
crate_type = ["cdylib"]
name = "mybackendtest"

[dependencies]
diplomat = {path = "../diplomat/macro"}
diplomat-runtime = {path = "../diplomat/runtime"}
</code></pre>
<p>Because you are using path dependencies, it is important that your library project be in
the same directory as your fork of diplomat</p>
<p>Copy the following into your lib.rs</p>
<pre><code class="language-rs">#[diplomat::bridge]
mod ffi {

    #[diplomat::opaque]
    struct OpaqueStruct;

    impl OpaqueStruct {
        pub fn add_two(i: i32) -&gt; i32 {
            i + 2
        }
    }
}

</code></pre>
<p>Note it is very important that the method be marked <code>pub</code> otherwise diplomat will ignore it.
Now you can run</p>
<pre><code class="language-sh">cargo build
</code></pre>
<p>to create a debug artifact in <code>target/debug/libmybackendtest.dylib</code></p>
<h2 id="getting-access-to-your-native-method"><a class="header" href="#getting-access-to-your-native-method">Getting Access to your Native Method</a></h2>
<p>Now we can add code that will iterate over all of the methods of the opaque struct.
First, copy the impl block for <code>OpaqueStruct</code> into the test code underneath the <code>OpaqueStruct</code>.
Next, update your the code for <code>gen_opaque_def</code> to the following which will generate the native
symbol for your new impl method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::c2::CFormatter;

fn gen_opaque_def(ctx: &amp;TypeContext, type_id: TypeId, opaque_path: &amp;OpaqueDef) -&gt; String {
    let c_formatter = CFormatter::new(ctx);

    opaque_def
        .methods
        .iter()
        .map(|method| c_formatter.fmt_method_name(type_id, method))
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .join("\n")
}
<span class="boring">}</span></code></pre></pre>
<p>Now your snapshot should have the following contents</p>
<pre><code>---
source: tool/src/backend/mod.rs
assertion_line: 67
expression: generated
---
OpaqueStruct_add_two
</code></pre>
<p>where <code>OpaqueStruct_add_two</code> is the native symbol for your method. It has a simple signature <code>i32 -&gt; i32</code>,
so now you have a dynamic library and a symbol to load from it that you can start building. Now it is up
to you to figure how to integrate these into your host language project skeleton.</p>
<h2 id="minimal-backend"><a class="header" href="#minimal-backend">Minimal Backend</a></h2>
<p>You should now work on building a minimal backend that can generate opaque type definitions
with methods that only accept and return <a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/enum.PrimitiveType.html"><strong>primitive types</strong></a>.</p>
<p>You will need to update <code>tool/src/lib.rs</code> to add handling for your backend.</p>
<p>Once you have the basics of a backend you can add attribute handling. The best way to do this is to check the existing backends
e.g. <a href="https://github.com/rust-diplomat/diplomat/blob/b3a8702f6736dbd6e667638ca0025b8f8cd1509f/tool/src/lib.rs#L95">dart</a>(Note: git permalink may be out of date).
The most important is to ignore disabled types and methods, as then you can take advantage of diplomat's feature tests
and start building progressively.</p>
<h2 id="feature-tests"><a class="header" href="#feature-tests">Feature Tests</a></h2>
<p>Diplomat already includes feature tests that you can disable with <code>#[diplomat::attrs(disable, {backend})]</code>.
where <code>{backend}</code> refers to your new backend. As you add functionality to your backend you
can progressively enable the types and methods for your backend. This way you can iterate with
working examples. These are called via <a href="https://sagiegurari.github.io/cargo-make/">cargo-make</a>
e.g</p>
<pre><code class="language-sh">cargo make gen-dart-feature
</code></pre>
<p>You can look at <code>Makefile.toml</code> to see how tasks are defined. Most of the generative tasks make use of this
<a href="https://github.com/rust-diplomat/diplomat/blob/b3a8702f6736dbd6e667638ca0025b8f8cd1509f/support/functions.ds#L1">duckscript function</a>
(<a href="https://sagiegurari.github.io/duckscript/">Duckscript</a> is a simple scripting language)</p>
<h2 id="backend-checklist"><a class="header" href="#backend-checklist">Backend Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.rs/diplomat_core/latest/diplomat_core/hir/enum.PrimitiveType.html"><strong>primitive types</strong></a>: This will be the most basic piece of the backend, and you will want
to implement them early in order to test your ability to correctly call methods.</li>
<li><input disabled="" type="checkbox"/>
<a href=""><strong>opaque types</strong></a>:
<ul>
<li><input disabled="" type="checkbox"/>
basic definiton</li>
<li><input disabled="" type="checkbox"/>
return a boxed opaque. This needs to be cleaned in managed languages.
You can use the autogenerated <code>{OpaqueName}_destroy({OpaqueName}*)</code> native method to clean up
the memory of the associated opaque.</li>
<li><input disabled="" type="checkbox"/>
as self parameter</li>
<li><input disabled="" type="checkbox"/>
as another parameter</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.rs/diplomat_core/0.7.0/diplomat_core/hir/struct.StructDef.html"><strong>structs</strong></a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.rs/diplomat_core/0.7.0/diplomat_core/hir/struct.EnumDef.html"><strong>enums</strong></a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.rs/diplomat_core/0.7.0/diplomat_core/hir/enum.SuccessType.html#variant.Writeable"><strong>writeable</strong></a></li>
<li><input disabled="" type="checkbox"/>
<a href="https://docs.rs/diplomat_core/0.7.0/diplomat_core/hir/enum.Slice.html"><strong>slices</strong></a>
<ul>
<li><input disabled="" type="checkbox"/>
primitive slices</li>
<li><input disabled="" type="checkbox"/>
str slices</li>
<li><input disabled="" type="checkbox"/>
owned slices should be kotlin arrays</li>
<li><input disabled="" type="checkbox"/>
slices of strings</li>
<li><input disabled="" type="checkbox"/>
strings</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
borrows. This is probably one of the trickiest things, as you need to ensure that managed objects don't get
cleaned up if something depends on them.
<ul>
<li><input disabled="" type="checkbox"/>
borrows of parameters</li>
<li><input disabled="" type="checkbox"/>
in struct fields</li>
</ul>
</li>
<li><input disabled="" type="checkbox"/>
nullables, i.e. returning option types.</li>
<li><input disabled="" type="checkbox"/>
fallibles, i.e. returning result types. The resulting native type will be a discriminated union.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
